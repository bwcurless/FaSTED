\documentclass[tikz]{standalone}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xparse}
\usetikzlibrary{calc}
\usetikzlibrary{matrix}
\usetikzlibrary{arrows.meta}

% Binary value zero padding taken from SO
\usepackage{xparse}
\ExplSyntaxOn
\int_new:N \g_fleet_number_of_zeros
\NewDocumentCommand\SetZeros{m}
{
	\int_gset:Nn \g_fleet_number_of_zeros {#1}
}
\NewDocumentCommand\PrependZeros{om}
{
	\IfValueTF{#1}
	{ \__fleet_count:ne {#1} {#2} }
	{ \__fleet_count:ne {\g_fleet_number_of_zeros} {#2} }
}
\cs_new:Npn \__fleet_count:nn #1#2
{
	\exp_args:Nf \__fleet_prepend:nn
	{ \int_max:nn { #1 - \str_count:n {#2} } { 0 } }
	{#2}
}
\cs_generate_variant:Nn \__fleet_count:nn { ne }
\cs_new:Npn \__fleet_prepend:nn #1#2
{ \prg_replicate:nn {#1}{0} #2 }
\ExplSyntaxOff

% XOR routine taken from SO...
\ExplSyntaxOn
\NewExpandableDocumentCommand{\bitwiseXor}{mm}
{
	\recuenco_bitwise_xor:nn { #1 } { #2 }
}

\cs_new:Nn \recuenco_bitwise_xor:nn
{
	\int_from_bin:e
	{
		\__recuenco_bitwise_xor:ee { \int_to_bin:n { #1 } } { \int_to_bin:n { #2 } }
	}
}
\cs_generate_variant:Nn \int_from_bin:n { e }

\cs_new:Nn \__recuenco_bitwise_xor:nn
{
	\__recuenco_bitwise_xor_binary:ee
	{
		\prg_replicate:nn
		{
			\int_max:nn { \tl_count:n { #1 } } { \tl_count:n { #2 } } - \tl_count:n { #1 }
		}
		{ 0 }
		#1
	}
	{
		\prg_replicate:nn
		{
			\int_max:nn { \tl_count:n { #1 } } { \tl_count:n { #2 } } - \tl_count:n { #2 }
		}
		{ 0 }
		#2
	}
}
\cs_generate_variant:Nn \__recuenco_bitwise_xor:nn { ee }

\cs_new:Nn \__recuenco_bitwise_xor_binary:nn
{
	\__recuenco_bitwise_xor_binary:w #1;#2;
}
\cs_generate_variant:Nn \__recuenco_bitwise_xor_binary:nn { ee }

\cs_new:Npn \__recuenco_bitwise_xor_binary:w #1#2;#3#4;
{
	\int_abs:n { #1-#3 }
	\tl_if_empty:nF { #2 } { \__recuenco_bitwise_xor_binary:w #2;#4; }
}

\ExplSyntaxOff

\begin{document}

\definecolor{colColor0}{RGB}{255, 102, 102} % Soft Red  
\definecolor{colColor1}{RGB}{255, 140, 115} % Coral  
\definecolor{colColor2}{RGB}{255, 178, 140} % Soft Orange  
\definecolor{colColor3}{RGB}{230, 153, 190} % Warm Pink  
\definecolor{colColor4}{RGB}{200, 130, 220} % Light Orchid  
\definecolor{colColor5}{RGB}{170, 110, 230} % Soft Violet  
\definecolor{colColor6}{RGB}{140, 90, 240}  % Muted Purple  
\definecolor{colColor7}{RGB}{120, 70, 250}  % Gentle Blue-Purple  
\definecolor{lastColColor}{RGB}{255, 255, 255}  % White
\definecolor{AFragmentColor}{RGB}{255, 0, 0}  % Red
\definecolor{BFragmentColor}{RGB}{0, 0, 255}  % Blue
\definecolor{DFragmentColor}{RGB}{0, 203, 74}  % Green
\definecolor{ASharedMemColor}{RGB}{200, 0, 0}  % Red
\definecolor{BSharedMemColor}{RGB}{0, 0, 200}  % Blue
\definecolor{WarpTileColor}{RGB}{0, 150, 74}  % Green
\definecolor{BlockTileColor}{RGB}{0, 0, 0}  % Black

\definecolor{blockTileColor}{RGB}{0, 255, 0}  % Light Green

\newcommand{\getcolor}[1]{colColor#1}


\def\blockHeight{1}
\def\blockWidth{2}
\pgfmathsetmacro{\halfBlockHeight}{\blockHeight / 2}
\pgfmathsetmacro{\halfBlockWidth}{\blockWidth / 2}

\def\dimColors{colColor0, colColor1, colColor2, colColor3, colColor4, colColor5, colColor6, colColor7, lastColColor}

% Global Memory layout
\begin{tikzpicture}[scale=1]
	\foreach \color [count=\col from 0] in \dimColors {
		\foreach \row in {0,..., 7}{

			% Rectangle coordinates
			\pgfmathsetmacro{\yPos}{-\row * \blockHeight}
			\pgfmathsetmacro{\xPos}{\col * \blockWidth}
			\coordinate (UL) at (\xPos, \yPos);
			\coordinate (BR) at  (\xPos + \blockWidth, \yPos - \blockHeight);
			% Center of rectangle
			\coordinate (C) at ($ (UL)!.5!(BR) $);

			% Main rectangle
			\fill[color=\color, draw=black] (UL) rectangle (BR);

			% Label rows with Point number
			\ifnum\col=0
				\pgfmathsetmacro{\pointNum}{int(\row + 1)}
				\pgfmathsetmacro{\poffset}{-(\halfBlockWidth + 0.5)}
				\node[font=\large, xshift=\poffset cm] at (C) {$P_\pointNum$};
			\fi


			% Add dimension labels
			\pgfmathsetmacro{\baseDim}{int((\col) * 8 + 1)}
			% Handle last col differently since it goes to d
			\ifnum\col=8
				\node[font=\large] at (C)  {\baseDim ...$d$};
			\else
				% Label with thread tileIndex
				\pgfmathsetmacro{\cellIndex}{int((\row) * 8 + \col)}
				\node[anchor=north west, font=\tiny] at (UL) {T\cellIndex};
				\pgfmathsetmacro{\maxDim}{int(\baseDim + 7)}
				\node[font=\large] at (C)  {\baseDim -\maxDim};
			\fi

	}};
\end{tikzpicture}

% Shared Memory layout
\begin{tikzpicture}[scale=1]
	\node[font=\large] at (8, 0) {\underline{Shared Memory Banks}};
	\begin{scope}[shift={(0,-1.25)}]

		\foreach \col in {0,...,7} {
			\foreach \row in {0,..., 7}{

			% Base calculations
				\pgfmathsetmacro{\yPos}{-\row * \blockHeight}
				\pgfmathsetmacro{\xPos}{\col * \blockWidth}
				\coordinate (UL) at (\xPos, \yPos);
				\coordinate (BR) at  (\xPos + \blockWidth, \yPos - \blockHeight);
			% Center of rectangle
				\coordinate (C) at ($ (UL)!.5!(BR) $);

			% Compute swizzled column
				\pgfmathsetmacro{\swizzledCol}{int(\bitwiseXor{\col}{\row})}

			% Draw rect with appropriate column color
				\def\cellColor{\getcolor{\swizzledCol}}
				\fill[color=\cellColor, draw=black] (UL) rectangle (BR);

			% Label rows with Point number
				\ifnum\col=0
					\pgfmathsetmacro{\pointNum}{int(\row + 1)}
					\pgfmathsetmacro{\poffset}{-(\halfBlockWidth + 0.5)}
					\node[font=\large, xshift=\poffset cm] at (C) {$P_\pointNum$};
				\fi

				\pgfmathsetmacro{\headerOffset}{(\halfBlockHeight + 0.5)}
			% Label columns with bank number
				\ifnum\row=0
			% Add column number in binary
					\pgfmathsetmacro{\binaryColumn}{int(bin(\col)}
					\newcommand\paddedBinaryAddress{\PrependZeros[3]{\binaryColumn}}

					\pgfmathsetmacro{\bank}{int(\col+1)}
					\node[font=\large, yshift=\headerOffset cm] at (C) {$ b_\mathtt{\paddedBinaryAddress} $};
				\fi

				\pgfmathsetmacro{\binaryRow}{int(bin(\row))}
			% Add XOR values to right side of figure
				\ifnum\col=7
					\pgfmathsetmacro{\xorOffset}{(\halfBlockWidth + 0.1)}
				% Add header for XOR column...
					\ifnum\row=0
						\node[anchor=west, font=\small, xshift=\xorOffset cm, yshift=\headerOffset cm] at (C) {\underline{XOR}};
					\fi
					\newcommand\paddedBinaryRow{\PrependZeros[3]{\binaryRow}}
					\node[anchor=west, font=\small, xshift=\xorOffset cm] at (C) {\texttt{0b\paddedBinaryRow}};
				\fi

			% Add dimension range for each block
				\pgfmathsetmacro{\baseDim}{int(8 * \swizzledCol + 1)}
				\pgfmathsetmacro{\maxDim}{int(\baseDim + 7)}
				\node[font=\large] at (C)  {\baseDim -\maxDim};


		}};
	\end{scope}
\end{tikzpicture}

% Fragment drawings common parameters

% Base rectangle background
\newcommand\whiteSpace{0.5}

	% Compute width of a single register based on the fraction of a single chunk it takes up.
\pgfmathsetmacro\registerWidth{0.75}
\pgfmathsetmacro\registerHeight{0.375}
\pgfmathsetmacro\halfRegisterWidth{\registerWidth / 2}
\pgfmathsetmacro\halfRegisterHeight{\registerHeight / 2}

\newcommand\phasesPercent{0.8}
\pgfmathsetmacro\phaseWidth{\registerWidth * 4}
\pgfmathsetmacro\phaseHeight{\registerHeight * 8}

\pgfmathsetmacro\fragmentWidth{2 * \phaseWidth + (3 * \whiteSpace)}
\pgfmathsetmacro\fragmentHeight{2 * \phaseHeight + (3 * \whiteSpace)}

\tikzstyle fragment=[ultra thick, rounded corners= 5pt]

\newcommand\drawFragment[1]{
	\draw[style=fragment, draw=AFragmentColor] (0, 0) rectangle +(\fragmentWidth, -\fragmentHeight);

	\begin{scope}[xshift=\whiteSpace cm, yshift=-\whiteSpace cm]

	% Draw the four phases
		\foreach \row in {0,  1} {
			\foreach \col in {0,  1} {
				\pgfmathsetmacro\xoffset{\col * (\phaseWidth + \whiteSpace)}
				\pgfmathsetmacro\yoffset{-\row * (\phaseHeight + \whiteSpace)}
				\begin{scope}[xshift=\xoffset cm, yshift=\yoffset cm]
					\pgfmathsetmacro\phaseNum{int(\col * 2 + \row + 1)}
					\node[anchor=south] at (\registerWidth * 2, 0) {Phase \phaseNum};
					% Invoke the Phase drawing section now that we are in our local scope
					#1{\phaseNum}
				\end{scope}
			}
		}
	\end{scope}
}

\newcommand\getPhaseColor[1]{%
	\ifcase #1 \or colColor0%
		\or white%
		\or colColor1%
		\or white%
	\fi
}

% Chunk based fragment
\begin{tikzpicture}

	\newcommand\drawChunkPhase[1]{
			% edef worked here because I was defining \def\phaseNum{\phaseNum} which recurses
			% infinitely. \edef worked because it expanded \phaseNum before assigning it to 
			% the new macro.
		\def\phaseNumIn{#1}
% Thread\register layout
		\foreach \row in {0, ..., 7} {
			\coordinate (C) at (0, -\row * \registerHeight);
			\ifnum \phaseNumIn<3
				\def\firstDim{1}
			\else
				\def\firstDim{9}
			\fi
			\pgfmathsetmacro\maxDim{int(\firstDim + 7)}

			\def\chunkColor{\getPhaseColor{\phaseNumIn}}
			\pgfmathsetmacro\thread{int((\phaseNumIn - 1) * 8 + \row)}
			\filldraw[fill=\chunkColor, draw=black] (C) node[anchor=north west, font=\tiny] {\texttt{T\thread}} rectangle +(4 * \registerWidth, -\registerHeight) node[midway, font=\small] {\firstDim-\maxDim} ;
		}
	}

	\drawFragment{\drawChunkPhase}

\end{tikzpicture}

% Register based fragment
\begin{tikzpicture}

	\newcommand\drawThreadPhase[1]{
		\edef\phaseNum{#1}
% Thread\register layout
		\foreach \phaseRow in {0, ..., 7} {
			\foreach \phaseCol in {0, ..., 3}{
				\coordinate (C) at (\phaseCol * \registerWidth, -\phaseRow * \registerHeight);
				\pgfmathsetmacro\threadIndex{int(\phaseRow * 4 + \phaseCol)}
				\def\chunkColor{\getPhaseColor{\phaseNum}}
				\filldraw[fill=\chunkColor, draw=black] (C) rectangle +(\registerWidth, -\registerHeight) node[midway, font=\small] {\texttt{T\threadIndex}};
			}
		}
	}

	\drawFragment{ \drawThreadPhase }

\end{tikzpicture}

% Basic TC MMA
\begin{tikzpicture}
	\newcommand\fm{4.5}
	\newcommand\fn{3}
	\newcommand\fk{4.5}

		% Draw B
	\pgfmathsetmacro\bdXShift{1.5}
	\draw[style=fragment,draw=BFragmentColor, ultra thick] (0, 0) rectangle +(\fn, -\fk);
	\matrix (m) [xshift=\bdXShift cm, yshift=-2.25cm, 
	matrix of math nodes,
	row sep=0.5em, column sep=0em,
	nodes={anchor=center}] {
		C_{1,1} & \cdots & C_{8,1} \\
		C_{1,2} & \cdots & C_{8,2} \\
		\vdots & \ddots & \vdots \\
		C_{1,15} & \cdots & C_{8,15} \\
		C_{1,16} & \cdots & C_{8,16} \\
	};

		% Draw D
	\pgfmathsetmacro\dXShift{0}
	\pgfmathsetmacro\dYShift{-\whiteSpace - \fk}
	\draw[style=fragment,draw=DFragmentColor, xshift=\dXShift cm, yshift=\dYShift cm, ultra thick] (0, 0) rectangle +(\fn, -\fm);
	\pgfmathsetmacro\adYShift{-7.25}
	\matrix (m) [xshift=\bdXShift cm, yshift=\adYShift cm, 
	matrix of math nodes,
	row sep=0.5em, column sep=0em,
		%left delimiter={[}, right delimiter={]},
	nodes={anchor=center}] {
		D_{1,1} & \cdots & D_{1,8} \\
		D_{2,1} & \cdots & D_{2,8} \\
		\vdots & \ddots & \vdots \\
		D_{15,1} & \cdots & D_{15,8} \\
		D_{16,1} & \cdots & D_{16,8} \\
	};

		% Draw A
	\pgfmathsetmacro\aXShift{-\whiteSpace - \fk}
	\pgfmathsetmacro\aYShift{-\whiteSpace - \fm}
	\draw[style=fragment,draw=AFragmentColor, xshift=\aXShift cm, yshift=\aYShift cm, ultra thick] (0, 0) rectangle +(\fk, -\fm);
	\matrix (m) [xshift=-2.75 cm, yshift=\adYShift cm, 
	matrix of math nodes,
	row sep=0.5em, column sep=0.5em,
	nodes={anchor=center}] {
		Q_{1,1} & Q_{1,2} & \cdots & Q_{1,16} \\
		Q_{2,1} & Q_{2,2} & \cdots & Q_{2,16} \\
		\vdots & \vdots & \ddots & \vdots \\
		Q_{15,1} & Q_{15,2} & \cdots & Q_{15,16} \\
		Q_{16,1} & Q_{16,2} & \cdots & Q_{16,16} \\
	};

\end{tikzpicture}

% Warp MMA
\begin{tikzpicture}
	\newcommand\fm{2}
	\newcommand\fn{1}
	\newcommand\fk{2}

\end{tikzpicture}

% Block Tile Rasterization
\begin{tikzpicture}
		% Draw global memory layouts
	\newcommand\kHeight{2}
	\newcommand\mHeight{5.5}
	\tikzstyle nodeStyle=[align=center, font=\tiny]
	\draw[xshift=-2.25 cm, yshift=0 cm, style=fragment, draw=red] (0, 0) rectangle +(\kHeight, -\mHeight) node[midway, style=nodeStyle] {Query Points\\ (DRAM)};
	\draw[xshift=0 cm, yshift=0.25 cm, style=fragment, draw=blue] (0, \kHeight) rectangle +(\mHeight, -\kHeight) node[midway, style=nodeStyle] {Candidate Points\\ (DRAM)};

	\newcommand\tileSpacing{0.5}
	\newcommand\tileDim{1}

	\pgfmathsetmacro\paddedTileDim{\tileDim + \tileSpacing}

		% Remember the last node that we need to draw an arrow from
	\def\innerTiles{2}
	\def\outerChunks{2}

		% Outer square rasterized chunks
	\pgfmathsetmacro\outerRange{int(\outerChunks - 1)}

	\foreach \outerRow in {0, ..., \outerRange} {
		\foreach \outerCol in {0, ..., \outerRange} {
			\pgfmathsetmacro\outerIndex{int(\outerRow * \outerChunks + \outerCol)}
			\begin{scope}[xshift=\outerCol * \innerTiles * \paddedTileDim cm,
				yshift=-\outerRow * \innerTiles * \paddedTileDim cm]

				% inner square rasterized chunks
				\pgfmathsetmacro\innerRange{int(\innerTiles - 1)}
				\foreach \row in {0, ..., \innerRange} {
					\foreach \col in {0, ..., \innerRange} {
						\pgfmathsetmacro\innerIndex{int(\row * \innerTiles + \col + 1)}
						\pgfmathsetmacro\tileIndex{int(\outerIndex * (\innerTiles * \innerTiles) + \innerIndex)}

						\coordinate (TileUL) at (\col * \paddedTileDim, -\row * \paddedTileDim);
						\draw[style=fragment, draw=black] (TileUL) rectangle ++(\tileDim, -\tileDim) node[midway, font=\tiny, align=center, color=BlockTileColor] {Block\\ Tile\\ \tileIndex};

																		% Compute left and right nodes for arrows
						\coordinate (currentRightNode) at ($(TileUL) + (\tileDim, -\tileDim / 2)$);
						\coordinate (currentLeftNode) at ($(TileUL) + (0, -\tileDim / 2)$);
						\coordinate (currentBottomNode) at ($(TileUL) + (\tileDim / 2, -\tileDim)$);
						\coordinate (currentTopNode) at ($(TileUL) + (\tileDim / 2, 0)$);
						\tikzstyle arrow=[arrows= -{Stealth[length=2mm]}, thick, rounded corners= 0.5mm]
																% Draw connecting arrows
						\newcommand\arrowOffset{\tileSpacing / 2}

						\newcommand\drawOuterShortArrow{
							\ifnum \innerIndex=1
								\draw[style=arrow] (lastRightNode) -- ++(\arrowOffset, 0) -- ++(0, \innerTiles * \paddedTileDim - \paddedTileDim) -- ++(\arrowOffset, 0);
							\fi
						}
						\newcommand\drawOuterLongArrow{
							\ifnum \innerIndex=1
								\draw[style=arrow] (lastBottomNode) -- ++(0 , -\tileSpacing / 2) -- ++(-4 * \paddedTileDim + \paddedTileDim, 0) -- ++(0, -\arrowOffset);
							\fi
						}
																		% Draw outer-raster-square connecting arrows
						\ifnum \outerIndex=1
							\drawOuterShortArrow{}
						\fi
						\ifnum \outerIndex=2
							\drawOuterLongArrow{}
						\fi
						\ifnum \outerIndex=3
							\drawOuterShortArrow{}
						\fi
																		% Draw normal inner connecting arrows
						\ifnum \col>0
							\draw[style=arrow] (lastRightNode) -- +(\tileSpacing, 0);
						\fi
																		% Draw last to first connecting arrows
						\ifnum \col=0
							\ifnum \row>0
								\draw[style=arrow] (lastBottomNode) -- ++(0, -\tileSpacing / 2) -- ++(-\innerTiles * \paddedTileDim + \paddedTileDim, 0) -- ++(0 , -\tileSpacing / 2);
							\fi
						\fi

																		% Save the last right node for the next iteration to connect
																		% arrows to it
						\coordinate (lastLeftNode) at (currentLeftNode);
						\coordinate (lastRightNode) at (currentRightNode);
						\coordinate (lastTopNode) at (currentTopNode);
						\coordinate (lastBottomNode) at (currentBottomNode);

					}
				}
			\end{scope}
		}
	}

\end{tikzpicture}

% Warp Tile
\begin{tikzpicture}
	\newcommand\drawStackableFragment[5]{%
		\def\width{#1}
		\def\height{#2}
		\def\upperLeftContent{#3}
		\def\bottomRightContent{#4}
		\def\color{#5}

		\filldraw[style=fragment, fill= white, draw=\color] (0, 0) node[anchor=south east, font=\tiny, xshift=0.5 mm, yshift=-0.5 mm] {\bottomRightContent} rectangle (-\width, \height) node[anchor=north west, font=\tiny] {\upperLeftContent};
	}


	\newcommand\fullFragWidth{2}
	\newcommand\fullFragHeight{2}
	\newcommand\halfFragWidth{1}
	\newcommand\halfFragPoints{8}
	\newcommand\fullFragPoints{16}
				% All fragments have 16 dimensions
	\newcommand\fragmentDims{16}

				% Can be used to draw stacks of fragments for A or B matrices
	\newcommand\drawFragmentStack[5]{%
		\def\fragColor{#1}
		\def\fragWidth{#2}
		\def\fragWidthInPoints{#3}
		\def\fragIndex{#4}
		\def\fragName{#5}

								% Draw each fragment as a stack of 4
		\newcommand\stacks{4}
		\newcommand\stackOffset{0.4}
		\pgfmathsetmacro\maxStackIndex{int(\stacks - 1)}

		\foreach \i in {0, ..., \maxStackIndex} {
								% Stack up and to the left
			\begin{scope}[xshift=-\i * \stackOffset * 0.25 cm, yshift=\i * \stackOffset cm]
				\pgfmathtruncatemacro\minPoint{\fragWidthInPoints * \fragIndex + 1}
				\pgfmathtruncatemacro\maxPoint{\minPoint + \fragWidthInPoints - 1}

																% Kind of a hack, but we stack upwards so later fragments cover earlier, have
																% to count backwards for dimensions for this to work out cleanly
				\pgfmathtruncatemacro\maxDim{64 - (\i * \fragmentDims)}
				\pgfmathtruncatemacro\minDim{\maxDim - \fragmentDims + 1}

				\drawStackableFragment{\fragWidth}{\fullFragHeight}{$\fragName_{\minPoint,\minDim}$}{$\fragName_{\maxPoint,\maxDim}$}{\fragColor}
			\end{scope}
		}
	}

	\newcommand\fragXShift{1.5}
	\newcommand\fragYShift{4}

								% Draw all D Fragments
	\begin{scope}[xshift=1 cm, yshift=0 cm]
		\foreach \row in {0, ..., 2} {
			\foreach \col in {0, ..., 5} {
				\begin{scope}[xshift=\fragXShift * \col cm, yshift= -\fragYShift * \row cm]
					\pgfmathtruncatemacro\firstQueryPoint{\row * \fullFragPoints + 1}
					\pgfmathtruncatemacro\lastQueryPoint{\firstQueryPoint + \fullFragPoints - 1}
					\pgfmathtruncatemacro\firstCandPoint{\col * \halfFragPoints + 1}
					\pgfmathtruncatemacro\lastCandPoint{\firstCandPoint + \halfFragPoints - 1}


					\drawStackableFragment{\halfFragWidth}{\fullFragHeight}{$D_{\firstQueryPoint,\firstCandPoint}$}{$D_{\lastQueryPoint,\lastCandPoint}$}{DFragmentColor}
				\end{scope}
			}
		}
	\end{scope}

				% Draw all 3 A Fragments
	\begin{scope}[xshift=-1 cm, yshift=0 cm]
		\foreach \fragment in {0, ..., 2} {
			\begin{scope}[yshift=-\fragYShift * \fragment cm]
				\drawFragmentStack{AFragmentColor}{\fullFragWidth}{16}{\fragment}{Q}
			\end{scope}
		}
	\end{scope}

				% Draw all 6 B Fragments
	\begin{scope}[xshift=1 cm, yshift=3 cm]
		\foreach \fragment in {0, ..., 5} {
			\begin{scope}[xshift=\fragXShift * \fragment cm]
				\drawFragmentStack{BFragmentColor}{\halfFragWidth}{8}{\fragment}{C}
			\end{scope}
		}

	\end{scope}


\end{tikzpicture}

% Block Tile last one!!!
\begin{tikzpicture}

	\newcommand\drawBlockLevelFragment[6]{%
		\def\width{#1}
		\def\height{#2}
		\def\upperLeftContent{#3}
		\def\bottomRightContent{#4}
		\def\color{#5}
		\def\label{#6}

		\filldraw[style=fragment, fill= white, draw=\color] (0, 0) node[anchor=south east, font=\small] {\bottomRightContent} rectangle (-\width, \height) node[anchor=north west, font=\small] {\upperLeftContent} node[midway, align=center, font=\small] {\label};
	}

% Draw the entire block tile
	\draw[color=BlockTileColor, style=fragment, xshift=-9 cm, yshift=9 cm] (0,0) rectangle (15, -15) node[anchor=south east] {Single Block Tile};

	% Draw the 4 warp tiles in center
	\newcommand\warpTileSize{4}
	\newcommand\warpPadding{1}
	\pgfmathtruncatemacro\paddedWarpTileSize{\warpTileSize + \warpPadding}


	% Draw all Warp Tiles
	\begin{scope}[xshift=0 cm, yshift=0 cm]
		\foreach \row in {0, ..., 1} {
			\foreach \col in {0, ..., 1} {
				\begin{scope}[xshift=\paddedWarpTileSize * \col cm, yshift= -\paddedWarpTileSize * \row cm]
					\pgfmathtruncatemacro\warpIndex{\row * 2 + \col + 1}
					\pgfmathtruncatemacro\warpSize{48}

					\pgfmathtruncatemacro\minQueryPoint{\row * \warpSize + 1}
					\pgfmathtruncatemacro\maxQueryPoint{\minQueryPoint + \warpSize - 1}
					\pgfmathtruncatemacro\minCandPoint{\col * \warpSize + 1}
					\pgfmathtruncatemacro\maxCandPoint{\minCandPoint + \warpSize - 1}
					\def\minDim{1}
					\def\maxDim{64}

					\drawBlockLevelFragment{\warpTileSize}{\warpTileSize}{$D_{\minQueryPoint,\minCandPoint}$}{$D_{\maxQueryPoint,\maxCandPoint}$}{WarpTileColor}{Warp\\ \warpIndex}
				\end{scope}
			}
		}
	\end{scope}

	% Draw the 64D shared memory chunks that have been paged in
	% A Data
	\begin{scope}[xshift=-5 cm, yshift=-5 cm]
		\drawBlockLevelFragment{\warpTileSize * 0.75}{2 * \warpTileSize + \warpPadding}{$Q_{1,1}$}{$Q_{96,64}$}{ASharedMemColor}{Query Points\\ 64D k-slice\\ (SMEM)}
	\end{scope}

	% B Data
	\begin{scope}[xshift=5 cm, yshift=5 cm]
		\pgfmathsetmacro\blockWidth{2 * \warpTileSize + \warpPadding}
		\drawBlockLevelFragment{\blockWidth}{\warpTileSize * 0.75}{$C_{1,1}$}{$C_{96,64}$}{BSharedMemColor}{Candidate Points\\ 64D k-slice (SMEM)}
	\end{scope}

\end{tikzpicture}

\end{document}
