\documentclass[tikz,border=2mm]{standalone}

\input{tikz_src/diagramResources.tex}

\begin{document}
% Warp Tile
\begin{tikzpicture}[show background rectangle, 
    background rectangle/.style={style=fragment, fill=WarpTileColor}]
	\newcommand\drawStackableFragment[6]{%
		\def\width{#1}
		\def\height{#2}
		\def\upperLeftContent{#3}
		\def\bottomRightContent{#4}
		\def\singlefragcolor{#5}
            \def\label{#6}

            \def\labelShift{0.8}

		\filldraw[style=fragment, fill=\singlefragcolor, draw=black] (0, 0) node[anchor=south east,  font=\tiny, xshift=0.5 mm, yshift=-\labelShift mm, text=white] {\bottomRightContent} rectangle (-\width, \height) node[anchor=north west,  yshift=\labelShift mm, font=\tiny, text=white] {\upperLeftContent} node[midway,  align=center, font=\scriptsize, text=white] {\label};
	}


	\newcommand\fullFragWidth{1.5}
	\pgfmathsetmacro\fullFragHeight{\fullFragWidth}
	\pgfmathsetmacro\halfFragWidth{\fullFragWidth / 2}
	\newcommand\halfFragPoints{8}
	\newcommand\fullFragPoints{16}
	% All fragments have 16 dimensions
	\newcommand\fragmentDims{16}

	% Can be used to draw stacks of fragments for A or B matrices
	\newcommand\drawFragmentStack[6]{%
		\def\fragColor{#1}
		\def\fragWidth{#2}
		\def\fragWidthInPoints{#3}
		\def\fragIndex{#4}
		\def\fragName{#5}
            % Center label
		\def\fragLabel{#6}

		% Draw each fragment as a stack 
		\newcommand\stacks{2}
		\newcommand\stackOffset{0.325}
		\pgfmathsetmacro\maxStackIndex{int(\stacks - 1)}

		\foreach \i in {0, ..., \maxStackIndex} {
			% Stack up and to the left
			\begin{scope}[xshift=-\i * \stackOffset * 0.125 cm, yshift=\i * \stackOffset cm]
				\pgfmathtruncatemacro\minPoint{\fragWidthInPoints * \fragIndex + 1}
				\pgfmathtruncatemacro\maxPoint{\minPoint + \fragWidthInPoints - 1}

																% Kind of a hack, but we stack upwards so later fragments cover earlier, have
																% to count backwards for dimensions for this to work out cleanly
				\pgfmathtruncatemacro\maxDim{\fragmentDims * \stacks - (\i * \fragmentDims)}
				\pgfmathtruncatemacro\minDim{\maxDim - \fragmentDims + 1}

				\drawStackableFragment{\fragWidth}{\fullFragHeight}{$\fragName_{\minPoint,\minDim}$}{$\fragName_{\maxPoint,\maxDim}$}{\fragColor}{\fragLabel}
			\end{scope}
		}
	}


	\newcommand\fragXShift{1.0}
	\newcommand\fragYShift{2.0}
	\newcommand\numAFragments{2}
	\pgfmathtruncatemacro\aFragmentsMaxIndex{\numAFragments - 1}
	\newcommand\numBFragments{4}
	\pgfmathtruncatemacro\bFragmentsMaxIndex{\numBFragments - 1}

	% Draw all D Fragments
	\begin{scope}[xshift=1 cm, yshift=0 cm]
		\foreach \row in {0, ..., \aFragmentsMaxIndex} {
			\foreach \col in {0, ..., \bFragmentsMaxIndex} {
				\begin{scope}[xshift=\fragXShift * \col cm, yshift= -\fragYShift * \row cm]
					\pgfmathtruncatemacro\firstQueryPoint{\row * \fullFragPoints + 1}
					\pgfmathtruncatemacro\lastQueryPoint{\firstQueryPoint + \fullFragPoints - 1}
					\pgfmathtruncatemacro\firstCandPoint{\col * \halfFragPoints + 1}
					\pgfmathtruncatemacro\lastCandPoint{\firstCandPoint + \halfFragPoints - 1}

					\drawStackableFragment{\halfFragWidth}{\fullFragHeight}{$a_{\firstQueryPoint,\firstCandPoint}$}{$a_{\lastQueryPoint,\lastCandPoint}$}{DFragmentColor}{\arf}
				\end{scope}
			}
		}
	\end{scope}

	% Draw all 2 A Fragments
	\begin{scope}[xshift=0 cm, yshift=0 cm]
		\foreach \fragment in {0, ..., \aFragmentsMaxIndex} {
			\begin{scope}[yshift=-\fragYShift * \fragment cm]
				\drawFragmentStack{AFragmentColor}{\fullFragWidth}{16}{\fragment}{p}{\prf}
			\end{scope}
		}
	\end{scope}

	% Draw all 4 B Fragments
	\begin{scope}[xshift=1 cm, yshift=1.75 cm]
		\foreach \fragment in {0, ..., \bFragmentsMaxIndex} {
			\begin{scope}[xshift=\fragXShift * \fragment cm]
				\drawFragmentStack{BFragmentColor}{\halfFragWidth}{8}{\fragment}{p}{\qrf}
			\end{scope}
		}

	\end{scope}

  % Draw the entire warp tile for future reference
	\drawLabeledBoundingBox{color=WarpTileColor}{Single Warp Tile}{black}

\end{tikzpicture}
\end{document}
